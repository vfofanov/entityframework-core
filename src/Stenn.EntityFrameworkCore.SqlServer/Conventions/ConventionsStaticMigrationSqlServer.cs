using System.Collections.Generic;
using System.Linq;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations.Operations;
using Stenn.EntityFrameworkCore.EntityConventions;
using Stenn.EntityFrameworkCore.StaticMigrations;
using Stenn.EntityFrameworkCore.StaticMigrations.Conventions;
using Stenn.EntityFrameworkCore.StaticMigrations.Enums;

namespace Stenn.EntityFrameworkCore.SqlServer.Conventions
{
    public class ConventionsStaticMigrationSqlServer : ConventionsStaticMigration
    {
        public ConventionsStaticMigrationSqlServer(DbContext context)
            : base(context)
        {
        }

        /// <inheritdoc />
        public override IEnumerable<MigrationOperation> GetRevertOperations()
        {
            yield return new SqlOperation
            {
                Sql = $@"
DECLARE conventions_triggers CURSOR
FOR
SELECT SCHEMA_NAME(t.schema_id), tr.name AS trigger_name FROM sys.triggers tr
INNER JOIN sys.tables t ON t.object_id = tr.parent_id
WHERE tr.name like CONCAT('%', '{NameSuffix}')

DECLARE @schema_name sysname, @trigger_name sysname

OPEN conventions_triggers
FETCH NEXT FROM conventions_triggers INTO @schema_name, @trigger_name

WHILE @@FETCH_STATUS = 0
BEGIN
  EXEC('DROP TRIGGER ['+@schema_name+'].['+@trigger_name+']')
  FETCH NEXT FROM conventions_triggers INTO @schema_name, @trigger_name
END
CLOSE conventions_triggers;
DEALLOCATE conventions_triggers;
"
            };
        }

        /// <inheritdoc />
        protected override IEnumerable<MigrationOperation> GetApplyOperations(IEntityType entity)
        {
            var identifier = entity.GetIdentifier();
            
            var insertTrigger = new List<(string Column, string? Value)>();
            var updateTrigger = new List<(string Column, string? Value)>();

            if (entity.FindAnnotation(ConventionsAnnotationNames.SoftDelete) is { })
            {
                var suffix = GetSuffix(identifier);
                var tableName = GetObjectName(identifier);
                var keyExpressionStr = GetKeyExpressionStr(entity, identifier, "t", "deleted");

                yield return new SqlOperation
                {
                    Sql = $@"
-- Soft delete trigger generated by convention. Controlled by static migrations
CREATE TRIGGER [{suffix}_SoftDelete{NameSuffix}]
    ON {tableName}
    INSTEAD OF DELETE
    AS
    IF @@ROWCOUNT = 0 RETURN;
    UPDATE {tableName}
    SET Deleted = GETDATE(), IsDeleted = 1
    FROM {tableName} t
        INNER JOIN deleted ON {keyExpressionStr}"
                };
            }

            foreach (var property in entity.GetProperties().OrderBy(p => p.Name))
            {
                if (property.FindAnnotation(ConventionsAnnotationNames.ColumnTriggerInsert) is { } columnTriggerInsert)
                {
                    insertTrigger.Add(
                        (
                            Column: property.GetFinalColumnName(identifier),
                            Value: columnTriggerInsert.Value?.ToString()
                        ));
                }
                if (property.FindAnnotation(ConventionsAnnotationNames.ColumnTriggerUpdate) is { } columnTriggerUpdate)
                {
                    updateTrigger.Add(
                        (
                            Column: property.GetFinalColumnName(identifier),
                            Value: columnTriggerUpdate.Value?.ToString()
                        ));
                }
            }
            #region insert_trigger
            if (insertTrigger.Count > 0)
            {
                var suffix = GetSuffix(identifier);
                var tableName = GetObjectName(identifier);
                var keyExpressionInsertedStr = GetKeyExpressionStr(entity, identifier, "t", "inserted");
                var updatingColumnsStr = string.Join(", ", updateTrigger.Select(p => $"[{p.Column}] = {p.Value}"));
                

                yield return new SqlOperation
                {
                    Sql = $@"
-- After update trigger generated by convention. Controlled by static migrations
CREATE TRIGGER [{suffix}_AfterInsert{NameSuffix}]
    ON {tableName}
    AFTER UPDATE
    AS
    IF @@ROWCOUNT = 0 RETURN;
    UPDATE {tableName}
    SET {updatingColumnsStr}
    FROM {tableName} t
        INNER JOIN inserted ON {keyExpressionInsertedStr}"
                };
            }
            #endregion
            #region update_trigger
            if (updateTrigger.Count > 0)
            {
                var suffix = GetSuffix(identifier);
                var tableName = GetObjectName(identifier);
                var keyExpressionInsertedStr = GetKeyExpressionStr(entity, identifier, "t", "inserted");
                var keyExpressionDeletedStr = GetKeyExpressionStr(entity, identifier, "t", "deleted");
                var updatingColumnsStr = string.Join(", ", updateTrigger.Select(p => $"[{p.Column}] = {p.Value}"));
                

                yield return new SqlOperation
                {
                    Sql = $@"
-- After update trigger generated by convention. Controlled by static migrations
CREATE TRIGGER [{suffix}_AfterUpdate{NameSuffix}]
    ON {tableName}
    AFTER UPDATE
    AS
    IF @@ROWCOUNT = 0 RETURN;
    UPDATE {tableName}
    SET {updatingColumnsStr}
    FROM {tableName} t
        INNER JOIN inserted ON {keyExpressionInsertedStr}
        INNER JOIN deleted ON {keyExpressionDeletedStr}"
                };
            }
            #endregion
        }

        private static string GetSuffix(StoreObjectIdentifier identifier)
        {
            return identifier.Name;
        }

        private static string GetObjectName(StoreObjectIdentifier identifier)
        {
            return !string.IsNullOrEmpty(identifier.Schema)
                ? $"[{identifier.Schema}].[{identifier.Name}]"
                : $"[{identifier.Name}]";
        }

        private static string GetKeyExpressionStr(IEntityType entity, StoreObjectIdentifier identifier,
            string leftTableAlias, string rightTableAlias)
        {
            var key = entity.FindPrimaryKey();
            if (key == null)
            {
                throw new StaticMigrationException($"Can't find primary key for {identifier}");
            }

            var keyExpression = string.Join(" AND ", key.Properties.Select(p =>
            {
                var columnName = p.GetFinalColumnName(identifier);
                return $"{leftTableAlias}.[{columnName}] = {rightTableAlias}.[{columnName}]";
            }));
            return keyExpression;
        }
    }
}